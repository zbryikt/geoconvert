// Generated by LiveScript 1.3.1
var fs, zlib, osmtogeojson, topojson, shapefile, bluebird, xmldom, coord, geoconvert;
fs = require('fs');
zlib = require('zlib');
osmtogeojson = require('osmtogeojson');
topojson = require('topojson');
shapefile = require('shapefile');
bluebird = require('bluebird');
xmldom = require('xmldom');
coord = require('coord');
geoconvert = {
  defaultConfig: {
    "quantization": undefined,
    "pre-quantization": 1e6,
    "post-quantization": 1e4,
    "simplify": 0,
    "simplify-proportion": 0,
    "coordinate-system": "cartesian",
    "cartesian": false,
    "spherical": false,
    "force-clockwise": true,
    "stitch-poles": true,
    "filter": "small-detached",
    "allow-empty": false,
    "id-property": null,
    "properties": false,
    "shapefile-encoding": null,
    "ignore-shapefile-properties": false,
    "longitude": "longitude",
    "latitude": "latitude",
    "projection": null,
    "width": null,
    "height": null,
    "margin": 0,
    "invert": "auto",
    "bbox": false
  },
  options: function(config){
    config = import$(import$({}, this.defaultConfig), config);
    return {
      "verbose": false,
      "pre-quantization": +config["pre-quantization"],
      "post-quantization": +config["post-quantization"],
      "coordinate-system": config.spherical
        ? 'spherical'
        : config.cartesian ? 'cartesian' : 'auto',
      "stitch-poles": config["stitch-poles"],
      "id": config["id-property"] || function(it){
        return it.id;
      },
      "property-transform": config["properties"] || function(it){
        return it.properties;
      },
      "minimum-area": config["simplify"],
      "preserve-attached": !deepEq$(config["filter"], "small", '==='),
      "retain-proportion": +config["simplify-proportion"],
      "force-clockwise": false
    };
  },
  twd97Gws84: function(data){
    var ref$, lat, lng, i$, len$, item, results$ = [];
    if (!data.length) {
      return;
    }
    if (typeof data[0] === typeof 0 && data[0] > 200) {
      ref$ = coord.toGws84(data[0], data[1]), lat = ref$.lat, lng = ref$.lng;
      return ref$ = [lng, lat], data[0] = ref$[0], data[1] = ref$[1], ref$;
    } else {
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        item = data[i$];
        results$.push(this.twd97Gws84(item));
      }
      return results$;
    }
  },
  clockwisify: function(data){
    var sum, i$, to$, i, j, len$, item, results$ = [];
    if (!data.length || !data[0].length) {
      return;
    }
    if (typeof data[0][0] === typeof 0) {
      sum = 0;
      for (i$ = 0, to$ = data.length; i$ < to$; ++i$) {
        i = i$;
        j = (i + 1) % data.length;
        sum += (data[j][0] - data[i][0]) * (data[j][1] + data[i][1]);
      }
      if (sum < 0) {
        return data.reverse();
      }
    } else {
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        item = data[i$];
        results$.push(this.clockwisify(item));
      }
      return results$;
    }
  },
  fixformat: function(geodata){
    var target, obj, bbox, i$, i, ref$, lat, lng, len$, feature;
    if (geodata.type === 'FeatureCollection') {
      target = {
        objects: {
          'default': {
            geometries: geodata.features
          }
        }
      };
    } else {
      for (obj in geodata.objects) {
        bbox = geodata.objects[obj].bbox;
        for (i$ = 0; i$ <= 2; i$ += 2) {
          i = i$;
          ref$ = coord.toGws84(bbox[i], bbox[i + 1]), lat = ref$.lat, lng = ref$.lng;
          ref$ = [lng, lat], bbox[i] = ref$[0], bbox[i + 1] = ref$[1];
        }
        target = geodata;
      }
    }
    for (obj in geodata.objects) {
      for (i$ = 0, len$ = (ref$ = target.objects[obj].geometries).length; i$ < len$; ++i$) {
        feature = ref$[i$];
        this.twd97Gws84(feature.geometry.coordinates);
        this.clockwisify(feature.geometry.coordinates);
      }
    }
    return geodata;
  },
  osm: {
    file: {
      toGeojson: function(filename){
        return new bluebird(function(res, rej){
          return fs.readFile(filename, function(e, osmdata){
            if (e) {
              return rej(e);
            }
            osmdata = osmdata.toString();
            return geoconvert.osm.toGeojson(osmdata).then(function(geodata){
              return res(geodata);
            })['catch'](function(e){
              return rej(e);
            });
          });
        });
      },
      toTopojson: function(filename){
        var this$ = this;
        return new bluebird(function(res, rej){
          return fs.readFile(filename, function(e, osmdata){
            if (e) {
              return rej(e);
            }
            osmdata = osmdata.toString();
            return geoconvert.osm.toTopojson(osmdata).then(function(topodata){
              return res(topodata);
            })['catch'](function(e){
              return rej(e);
            });
          });
        });
      }
    },
    toGeojson: function(osmdata){
      return new bluebird(function(res, rej){
        var osm;
        osm = new xmldom.DOMParser().parseFromString(osmdata, 'text/xml');
        return res(geoconvert.fixformat(osmtogeojson(osm)));
      });
    },
    toTopojson: function(osmdata){
      var this$ = this;
      return new bluebird(function(res, rej){
        return this$.toGeojson(osmdata).then(function(geodata){
          return res(geoconvert.geojson.toTopojson(geodata));
        })['catch'](function(e){
          return rej(e);
        });
      });
    }
  },
  shp: {
    file: {
      toGeojson: function(filename, config){
        config == null && (config = {});
        return new bluebird(function(res, rej){
          return shapefile.read(filename, {
            "encoding": config["shapefile-encoding"],
            "ignore-properties": !!config["ignore-shapefile-properties"]
          }, function(e, c){
            if (e) {
              return rej(e);
            }
            return res(c);
          });
        });
      },
      toTopojson: function(filename, config){
        var this$ = this;
        config == null && (config = {});
        return new bluebird(function(res, rej){
          var options;
          options = geoconvert.options(config);
          return this$.toGeojson(filename, config).then(function(c){
            return geoconvert.geojson.toTopojson(c, config).then(function(topodata){
              return res(topodata);
            });
          });
        });
      }
    }
  },
  geojson: {
    file: {
      toTopojson: function(filename, config){
        var this$ = this;
        config == null && (config = {});
        return new bluebird(function(res, rej){
          var geodata;
          geodata = JSON.parse(fs.readFileSync(filename).toString());
          return geoconvert.geojson.toTopojson(geodata, config).then(function(topodata){
            return res(topodata);
          })['catch'](function(e){
            return rej(e);
          });
        });
      }
    },
    toTopojson: function(geodata, config){
      var this$ = this;
      config == null && (config = {});
      return new bluebird(function(res, rej){
        var options, object;
        options = geoconvert.options(config);
        object = topojson.topology({
          'default': geodata
        }, options);
        if (config.width || config.height) {
          if (!deepEq$(options["coordinate-system"], 'cartesian', '===')) {
            return rej("width and height require Cartesian coordinates");
          }
          topojson.scale(object, {
            width: config.width,
            height: config.height,
            margin: config.margin,
            invert: config.invert
          });
        }
        if (+config["simplify"] > 0 || +config["simplify-proportion"] > 0) {
          topojson.simplify(object, options);
        }
        if (config["force-clockwise"]) {
          topojson.clockwise(object, options);
        }
        if (!deepEq$(config["filter"], 'none', '===')) {
          topojson.filter(object, options);
        }
        if (!config["bbox"]) {
          delete object.bbox;
        }
        return res(object);
      });
    }
  },
  topojson: {
    merge: function(topodata, geometryListHash){
      return new bluebird(function(res, rej){
        var simplify, fill, reorder, obj, k, v, ret, ref$, used, list, i$, len$, item, to$, idx;
        simplify = false;
        fill = function(a, h){
          var i$, len$, item, results$ = [];
          if (typeof a === typeof []) {
            for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
              item = a[i$];
              results$.push(fill(item, h));
            }
            return results$;
          } else {
            return h[Math.abs(a)] = 1;
          }
        };
        reorder = function(a, h){
          var i$, to$, idx;
          for (i$ = 0, to$ = a.length; i$ < to$; ++i$) {
            idx = i$;
            if (typeof a[idx] === typeof []) {
              a[idx] = reorder(a[idx], h);
            } else {
              a[idx] = (h[Math.abs(a[idx])] - 1) * (a[idx] < 0 ? -1 : 1);
            }
          }
          return a;
        };
        for (obj in topodata.objects) {
          topodata.objects[obj].geometries = (fn$());
        }
        if (simplify) {
          ref$ = [{}, []], used = ref$[0], list = ref$[1];
          for (obj in topodata.objects) {
            for (i$ = 0, len$ = (ref$ = topodata.objects[obj].geometries).length; i$ < len$; ++i$) {
              item = ref$[i$];
              fill(item.arcs, used);
            }
          }
          /* this part is to remove unused arc, but somehow not work correctly
          keys = [k for k of used]
          keys.sort!
          count = 1
          for idx in keys => 
            if used[idx] =>
              used[idx] = count
              count++
          for obj of topodata.objects
            for item in topodata.objects[obj]geometries => 
              item.arcs = reorder item.arcs, used
          
          for idx from 0 til topodata.arcs.length
            if used[idx] => list.push topodata.arcs[idx] 
          */
          for (i$ = 0, to$ = topodata.arcs.length; i$ < to$; ++i$) {
            idx = i$;
            if (used[idx]) {
              list.push(topodata.arcs[idx]);
            } else {
              list.push([]);
            }
          }
          topodata.arcs = list;
        }
        return res(topodata);
        function fn$(){
          var ref$, results$ = [];
          for (k in ref$ = geometryListHash[obj]) {
            v = ref$[k];
            ret = topojson.mergeArcs(topodata, v.list);
            ret.properties = v.properties;
            results$.push(ret);
          }
          return results$;
        }
      });
    }
  }
};
module.exports = geoconvert;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) {
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}